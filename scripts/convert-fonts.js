// scripts/convert-fonts.js

const fs = require('fs');
const path = require('path');

// 폰트 파일이 있는 소스 폴더
const fontsDir = path.join(process.cwd(), 'public', 'fonts');
// 변환된 코드가 저장될 목적지 폴더 및 파일
const generatedDir = path.join(process.cwd(), '.generated');
const outputFile = path.join(generatedDir, 'fonts.ts');

// 변환할 폰트 파일 목록과, 생성될 변수 이름 매핑
const fontMappings = [
  {
    inputFile: 'PretendardJP-Black.otf',
    variableName: 'pretendardBold',
  },
  {
    inputFile: 'PretendardJP-Medium.otf',
    variableName: 'pretendardRegular',
  },
  // 다른 폰트가 있다면 여기에 추가
];

try {
  // .generated 폴더가 없으면 생성
  if (!fs.existsSync(generatedDir)) {
    fs.mkdirSync(generatedDir);
  }

  let outputContent = `// This file is auto-generated by scripts/convert-fonts.js. Do not edit manually.\n`;
  outputContent += `// @ts-nocheck\n\n`; // 타입스크립트 검사 비활성화

  for (const mapping of fontMappings) {
    const fontPath = path.join(fontsDir, mapping.inputFile);

    // 폰트 파일을 버퍼(Buffer) 형태로 읽어옵니다.
    if (!fs.existsSync(fontPath)) {
      console.error(`'${fontPath}' 폰트 파일을 읽는 데 실패했습니다. 파일 경로를 확인하세요.`);
      process.exit(1); // 파일이 없으면 스크립트 중단
    }
    const fontBuffer = fs.readFileSync(fontPath);

    // 버퍼를 TypeScript 코드에서 사용할 수 있는 형태로 변환하여 문자열에 추가합니다.
    outputContent += `export const ${mapping.variableName} = { buffer: Buffer.from([${fontBuffer.join(',')}]) };\n`;
  }

  // 최종적으로 생성된 코드를 .generated/fonts.ts 파일에 씁니다.
  fs.writeFileSync(outputFile, outputContent);

  console.log(`✅ Font data successfully generated at ${outputFile}`);
} catch (error) {
  console.error('Error converting fonts:', error);
  process.exit(1); // 에러 발생 시 스크립트 중단
}