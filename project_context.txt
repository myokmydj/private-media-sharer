
============================================================
FILE: next.config.ts
============================================================

import type { NextConfig } from 'next';

const nextConfig: NextConfig = {
  images: {
    // remotePatterns 대신 domains를 사용합니다.
    // 여기에 Step 1에서 복사한 정확한 호스트 이름을 붙여넣으세요.
    domains: ['pub-36efcebb6f624798b7169d496005c244.r2.dev'], 
  },
};

export default nextConfig;


============================================================
FILE: package.json
============================================================

{
  "name": "private-media-sharer",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build --turbopack",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@aws-sdk/client-s3": "^3.901.0",
    "@aws-sdk/s3-request-presigner": "^3.901.0",
    "@vercel/postgres": "^0.10.0",
    "nanoid": "^5.1.6",
    "next": "15.5.4",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-markdown": "^10.1.0",
    "remark-gfm": "^4.0.1",
    "satori": "^0.18.3",
    "sharp": "^0.34.4"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4.1.14",
    "@tailwindcss/typography": "^0.5.19",
    "@types/node": "^20.19.19",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "autoprefixer": "^10.4.21",
    "dotenv": "^17.2.3",
    "eslint": "^9",
    "eslint-config-next": "15.5.4",
    "postcss": "^8.5.6",
    "tailwindcss": "^3.3.0",
    "typescript": "^5"
  }
}


============================================================
FILE: postcss.config.js
============================================================

// postcss.config.js

module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

============================================================
FILE: tailwind.config.ts
============================================================

// tailwind.config.ts

import type { Config } from 'tailwindcss';

const config: Config = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [
    require('@tailwindcss/typography'),
  ],
};
export default config;

============================================================
FILE: app/globals.css
============================================================

/* app/globals.css */

@tailwind base;
@tailwind components;
@tailwind utilities;

============================================================
FILE: app/layout.tsx
============================================================

import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}


============================================================
FILE: app/api/og/route.tsx
============================================================

import { ImageResponse } from 'next/og';
import { NextRequest } from 'next/server';
import { join } from 'path';
import * as fs from 'fs';

export const runtime = 'nodejs';

// 👇 두 개의 폰트 파일을 불러옵니다.
const fontBoldPath = join(process.cwd(), 'public', 'fonts', 'PretendardJP-Black.otf'); // 사용자님의 파일 이름으로
const fontRegularPath = join(process.cwd(), 'public', 'fonts', 'PretendardJP-Medium.otf'); // 사용자님의 파일 이름으로
const pretendardBold = fs.readFileSync(fontBoldPath);
const pretendardRegular = fs.readFileSync(fontRegularPath);

export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);

    const title = searchParams.get('title') || '제목 없음';
    const artist = searchParams.get('artist');
    const imageUrl = searchParams.get('imageUrl');
    // 👇 새로운 파라미터 수신
    const isBlurred = searchParams.get('isBlurred') === 'true';
    const isSpoiler = searchParams.get('isSpoiler') === 'true';

    return new ImageResponse(
      (
        <div style={{ height: '100%', width: '100%', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', backgroundColor: '#28234D', color: 'white', padding: '40px' }}>
          <div style={{ display: 'flex', width: '100%', height: '100%' }}>
            {imageUrl && (
              // eslint-disable-next-line @next/next/no-img-element
              <img
                src={imageUrl}
                alt=""
                width={550}
                height={550}
                style={{
                  borderRadius: '20px',
                  objectFit: 'cover',
                  // 👇 isBlurred 값에 따라 블러 효과 적용
                  filter: isBlurred ? 'blur(20px)' : 'none',
                }}
              />
            )}
            <div style={{ display: 'flex', flexDirection: 'column', marginLeft: '40px', flex: 1, justifyContent: 'space-between' }}>
              {/* 👇 상단 로고를 Font Awesome 음악 아이콘으로 교체 */}
              <div style={{ display: 'flex', justifyContent: 'flex-end', opacity: 0.8 }}>
                <svg xmlns="http://www.w3.org/2000/svg" height="80" width="80" viewBox="0 0 512 512" fill="white">
                  <path d="M499.1 6.3c-13.1-8.1-28.3-6.3-39.2 4.4L393.5 64H320c-17.7 0-32 14.3-32 32s14.3 32 32 32h64v64c0 17.7 14.3 32 32 32s32-14.3 32-32V128h6.5c13.8 0 26.1-8.1 31-20.5s.7-26.6-8.4-35.2L499.1 6.3zM23.1 406.3c-13.1-8.1-28.3-6.3-39.2 4.4L-82.5 464H-156c-17.7 0-32 14.3-32 32s14.3 32 32 32h64v64c0 17.7 14.3 32 32 32s32-14.3 32-32V528h6.5c13.8 0 26.1-8.1 31-20.5s.7-26.6-8.4-35.2L23.1 406.3zM256 0c-17.7 0-32 14.3-32 32V480c0 17.7 14.3 32 32 32s32-14.3 32-32V32c0-17.7-14.3-32-32-32z"/>
                </svg>
              </div>
              <div style={{ display: 'flex', flexDirection: 'column', fontFamily: '"PretendardJP-Black"' }}>
                <div style={{ fontSize: '60px', fontWeight: 'bold', letterSpacing: '-0.02em' }}>
                  {title}
                </div>
                {/* 👇 isSpoiler 값에 따라 본문 또는 스포일러 문구 표시 */}
                {artist && (
                  <div style={{
                    fontSize: '40px',
                    marginTop: '10px',
                    opacity: 0.7,
                    wordBreak: 'break-all',
                    lineHeight: 1.3,
                    // 👇 얇은 폰트 적용
                    fontFamily: '"PretendardJP-Medium"',
                    fontWeight: 400,
                  }}>
                    {isSpoiler ? '내용이 가려졌습니다.' : artist}
                  </div>
                )}
              </div>
              <div style={{ display: 'flex', justifyContent: 'flex-end' }}>
                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', width: '100px', height: '100px', backgroundColor: 'white', borderRadius: '50%' }}>
                  <svg width="50" height="50" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M8 5.13965V18.8604C8 19.56 8.66274 20.0168 9.30852 19.642L20.6915 12.7816C21.3373 12.4078 21.3373 11.5922 20.6915 11.2184L9.30852 4.35795C8.66274 3.98317 8 4.44004 8 5.13965Z" fill="#28234D"/>
                  </svg>
                </div>
              </div>
            </div>
          </div>
        </div>
      ),
      { width: 1200, height: 630, fonts: [{ name: 'PretendardJP-Black', data: pretendardBold, style: 'normal', weight: 800 }, { name: 'PretendardJP-Medium', data: pretendardRegular, style: 'normal', weight: 400 }] },
    );
  } catch (e: unknown) {
    if (e instanceof Error) console.error(`OG Image generation failed: ${e.message}`);
    else console.error('An unknown error occurred during OG Image generation');
    return new Response(`Failed to generate the image`, { status: 500 });
  }
}

============================================================
FILE: app/api/posts/route.ts
============================================================

import { NextResponse } from 'next/server';
import { db } from '@vercel/postgres';
import { nanoid } from 'nanoid';

export async function POST(request: Request) {
  try {
    const { title, content, thumbnailUrl, isThumbnailBlurred, isContentSpoiler } = await request.json();

    if (!title || !content || !thumbnailUrl) {
      return NextResponse.json({ error: '제목, 내용, 대표 이미지는 필수입니다.' }, { status: 400 });
    }

    const id = nanoid();

    await db.sql`
      INSERT INTO posts (id, title, content, thumbnail_url, is_thumbnail_blurred, is_content_spoiler)
      VALUES (${id}, ${title}, ${content}, ${thumbnailUrl}, ${isThumbnailBlurred}, ${isContentSpoiler});
    `;

    const baseUrl = process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : 'http://localhost:3000';
    const generatedUrl = `${baseUrl}/view/${id}`;

    return NextResponse.json({ success: true, url: generatedUrl });

  } catch (error) {
    console.error('Create Post API Error:', error);
    return NextResponse.json({ error: '게시물 생성 중 서버에서 에러가 발생했습니다.' }, { status: 500 });
  }
}

============================================================
FILE: app/api/upload/route.ts
============================================================

import { NextResponse } from 'next/server';
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
import { nanoid } from 'nanoid';

const s3Client = new S3Client({
  region: 'auto',
  endpoint: process.env.R2_ENDPOINT!,
  credentials: {
    accessKeyId: process.env.R2_ACCESS_KEY_ID!,
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY!,
  },
});

function getPublicUrl(filename: string): string {
  const publicUrlBase = process.env.NEXT_PUBLIC_R2_PUBLIC_URL!;
  return `${publicUrlBase.replace(/\/$/, '')}/${filename}`;
}

export async function POST(request: Request) {
  try {
    const formData = await request.formData();
    const file = formData.get('file') as File | null;

    if (!file) {
      return NextResponse.json({ error: '파일이 없습니다.' }, { status: 400 });
    }

    const buffer = Buffer.from(await file.arrayBuffer());
    const uniqueId = nanoid(10); // 짧은 고유 ID
    const key = `${uniqueId}-${file.name}`;

    const command = new PutObjectCommand({
      Bucket: process.env.R2_BUCKET_NAME!,
      Key: key,
      Body: buffer,
      ContentType: file.type,
    });
    
    await s3Client.send(command);

    const publicUrl = getPublicUrl(key);

    // 이제 DB에 저장하지 않고, 업로드된 파일의 URL과 파일명만 반환합니다.
    return NextResponse.json({ success: true, url: publicUrl, filename: file.name });

  } catch (error) {
    console.error('Upload API Error:', error);
    return NextResponse.json({ error: '파일 업로드 중 서버에서 에러가 발생했습니다.' }, { status: 500 });
  }
}

============================================================
FILE: app/upload/page.tsx
============================================================

'use client';

import { useState, ChangeEvent, FormEvent } from 'react';
import Image from 'next/image';

interface UploadedImage {
  url: string;
  filename: string;
}

export default function UploadPage() {
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  const [uploadedImages, setUploadedImages] = useState<UploadedImage[]>([]);
  const [selectedThumbnail, setSelectedThumbnail] = useState<string>('');
  
  // 👇 새로운 상태 추가
  const [isBlurred, setIsBlurred] = useState(false);
  const [isSpoiler, setIsSpoiler] = useState(false);

  const [isUploading, setIsUploading] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [generatedLink, setGeneratedLink] = useState('');
  const [error, setError] = useState('');

  const handleFileChange = async (event: ChangeEvent<HTMLInputElement>) => {
    // ... (이 함수는 변경 없음)
    const files = event.target.files;
    if (!files || files.length === 0) return;
    setIsUploading(true);
    setError('');
    for (const file of Array.from(files)) {
      const formData = new FormData();
      formData.append('file', file);
      try {
        const response = await fetch('/api/upload', { method: 'POST', body: formData });
        const data = await response.json();
        if (!response.ok) throw new Error(data.error);
        setContent(prev => `${prev}\n\n![${data.filename}](${data.url})`);
        setUploadedImages(prev => [...prev, { url: data.url, filename: data.filename }]);
        if (!selectedThumbnail) setSelectedThumbnail(data.url);
      } catch (err) {
        setError(err instanceof Error ? err.message : '파일 업로드 실패');
      }
    }
    setIsUploading(false);
  };

  const handleSubmit = async (event: FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    if (!title || !content || !selectedThumbnail) {
      setError('제목, 내용, 대표 이미지를 모두 설정해주세요.');
      return;
    }

    setIsSubmitting(true);
    setError('');
    setGeneratedLink('');

    try {
      // 👇 isThumbnailBlurred, isContentSpoiler 값을 함께 전송
      const response = await fetch('/api/posts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          title, 
          content, 
          thumbnailUrl: selectedThumbnail,
          isThumbnailBlurred: isBlurred,
          isContentSpoiler: isSpoiler,
        }),
      });

      const data = await response.json();
      if (!response.ok) throw new Error(data.error);

      setGeneratedLink(data.url);
      // 성공 시 폼 초기화
      setTitle('');
      setContent('');
      setUploadedImages([]);
      setSelectedThumbnail('');
      setIsBlurred(false);
      setIsSpoiler(false);

    } catch (err) {
      setError(err instanceof Error ? err.message : '게시물 생성 실패');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <main className="flex min-h-screen flex-col items-center justify-center p-4 sm:p-8 bg-gray-50">
      <div className="w-full max-w-3xl p-8 space-y-6 bg-white rounded-lg shadow-md">
        <h1 className="text-3xl font-bold text-center text-gray-800">새 게시물 작성</h1>
        <form onSubmit={handleSubmit} className="space-y-6">
          {/* ... (제목, 파일 업로드, 본문 입력 부분은 변경 없음) ... */}
          <div><label htmlFor="title" className="block text-sm font-medium text-gray-700">제목</label><input id="title" type="text" value={title} onChange={(e) => setTitle(e.target.value)} className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="게시물 제목을 입력하세요" required /></div>
          <div><label htmlFor="file" className="block text-sm font-medium text-gray-700">이미지 업로드 (여러 개 선택 가능)</label><input id="file" type="file" multiple onChange={handleFileChange} disabled={isUploading} className="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-violet-50 file:text-violet-700 hover:file:bg-violet-100" />{isUploading && <p className="text-sm text-gray-500 mt-2">업로드 중...</p>}</div>
          <div><label htmlFor="content" className="block text-sm font-medium text-gray-700">본문 (Markdown 지원)</label><textarea id="content" rows={10} value={content} onChange={(e) => setContent(e.target.value)} className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="내용을 입력하세요. 이미지 업로드 시 자동으로 추가됩니다." required /></div>
          
          {uploadedImages.length > 0 && (
            <div>
              <h3 className="text-sm font-medium text-gray-700">대표 이미지 선택 (SNS 미리보기에 사용)</h3>
              <div className="mt-2 grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 gap-2">
                {uploadedImages.map((image) => (
                  <div key={image.url} className="relative aspect-square cursor-pointer" onClick={() => setSelectedThumbnail(image.url)}>
                    <Image src={image.url} alt={image.filename} fill className={`object-cover rounded-md transition-all ${selectedThumbnail === image.url ? 'ring-4 ring-indigo-500' : 'ring-1 ring-gray-300'}`} />
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* 👇 새로운 UI: 미리보기 옵션 */}
          <div className="space-y-4 rounded-md border border-gray-200 p-4">
            <h3 className="text-sm font-medium text-gray-900">미리보기 옵션</h3>
            <div className="relative flex items-start">
              <div className="flex h-6 items-center">
                <input id="blur-toggle" type="checkbox" checked={isBlurred} onChange={(e) => setIsBlurred(e.target.checked)} className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-600" />
              </div>
              <div className="ml-3 text-sm leading-6">
                <label htmlFor="blur-toggle" className="font-medium text-gray-700">대표 이미지 흐리게 처리</label>
                <p className="text-gray-500">SNS 공유 시 썸네일을 블러 처리하여 가립니다.</p>
              </div>
            </div>
            <div className="relative flex items-start">
              <div className="flex h-6 items-center">
                <input id="spoiler-toggle" type="checkbox" checked={isSpoiler} onChange={(e) => setIsSpoiler(e.target.checked)} className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-600" />
              </div>
              <div className="ml-3 text-sm leading-6">
                <label htmlFor="spoiler-toggle" className="font-medium text-gray-700">본문 내용 스포일러 처리</label>
                <p className="text-gray-500">SNS 공유 시 본문 내용을 가립니다.</p>
              </div>
            </div>
          </div>

          <button type="submit" disabled={isSubmitting || isUploading} className="w-full px-4 py-2 text-lg font-medium text-white bg-indigo-600 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:bg-gray-400">
            {isSubmitting ? '생성 중...' : '공유 링크 생성'}
          </button>
        </form>

        {error && <p className="mt-4 text-sm text-center text-red-600">{error}</p>}
        {generatedLink && (
          <div className="mt-6 p-4 bg-green-50 border border-green-200 rounded-md">
            <p className="text-sm font-medium text-green-800">✅ 성공! 생성된 링크:</p>
            <a href={generatedLink} target="_blank" rel="noopener noreferrer" className="block mt-1 text-sm text-blue-600 break-all hover:underline">{generatedLink}</a>
          </div>
        )}
      </div>
    </main>
  );
}

============================================================
FILE: database_schema.sql
============================================================

-- posts ?뚯씠釉??앹꽦 荑쇰━ 諛??섏젙 荑쇰━
CREATE TABLE posts (
  id TEXT PRIMARY KEY,
  title TEXT NOT NULL,
  content TEXT,
  thumbnail_url TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  is_thumbnail_blurred BOOLEAN DEFAULT FALSE,
  is_content_spoiler BOOLEAN DEFAULT FALSE
);

============================================================
FILE: .env.local (?쒗뵆由?- ?ㅼ젣 媛믪? ?쒖쇅??
============================================================

# ?좑툘 以묒슂: ?ㅼ젣 媛믪? ?덈? ?몃???怨듭쑀?섎㈃ ???⑸땲??

# Vercel Postgres
POSTGRES_URL="postgres://..."

# Cloudflare R2
R2_BUCKET_NAME="YOUR_BUCKET_NAME"
R2_ENDPOINT="https://<ACCOUNT_ID>.r2.cloudflarestorage.com"
R2_ACCESS_KEY_ID="YOUR_R2_ACCESS_KEY_ID"
R2_SECRET_ACCESS_KEY="YOUR_R2_SECRET_ACCESS_KEY"
NEXT_PUBLIC_R2_PUBLIC_URL="https://pub-....r2.dev"

# Turbopack 鍮꾪솢?깊솕 (留뚯빟 ?ъ슜?덈떎硫?
NEXT_TURBOPACK=0

============================================================
FILE: "C:\Users\user\Downloads\Rproject\private-media-sharer\app\view\[id]\page.tsx"
============================================================


import { notFound } from 'next/navigation';
import { db } from '@vercel/postgres';
import type { Metadata } from 'next';
import { unstable_noStore as noStore } from 'next/cache';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';

interface Post {
  id: string;
  title: string;
  content: string;
  thumbnail_url: string;
  // 👇 새로운 속성 추가
  is_thumbnail_blurred: boolean;
  is_content_spoiler: boolean;
  created_at: string;
}

async function getPostData(id: string): Promise<Post | null> {
  noStore();
  try {
    // 👇 is_thumbnail_blurred, is_content_spoiler 컬럼을 함께 조회
    const { rows } = await db.sql`SELECT * FROM posts WHERE id = ${id} LIMIT 1;`;
    if (rows.length === 0) return null;
    return rows[0] as Post;
  } catch (error) {
    console.error("Database query failed:", error);
    return null;
  }
}

export async function generateMetadata({ params }: { params: { id:string } }): Promise<Metadata> {
  const post = await getPostData(params.id);

  if (!post) {
    return { title: '게시물을 찾을 수 없습니다' };
  }

  // --- 수정 후 코드 ---
  // 1. 스포일러 여부에 따라 표시될 설명을 결정합니다.
  const originalDescription = post.content ? post.content.replace(/\n/g, ' ').substring(0, 50) + (post.content.length > 50 ? '...' : '') : '';
  const displayDescription = post.is_content_spoiler 
    ? '내용이 가려졌습니다. 링크를 클릭해 확인하세요.' 
    : originalDescription || '친구로부터 공유된 게시물을 확인하세요.';

  const ogImageUrl = new URL(`${process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : 'http://localhost:3000'}/api/og`);
  ogImageUrl.searchParams.set('title', post.title);
  
  // OG 이미지 생성기에는 원본 내용을 보내 스포일러 처리를 맡깁니다.
  if (originalDescription) ogImageUrl.searchParams.set('artist', originalDescription);
  
  ogImageUrl.searchParams.set('imageUrl', post.thumbnail_url);
  ogImageUrl.searchParams.set('isBlurred', String(post.is_thumbnail_blurred));
  ogImageUrl.searchParams.set('isSpoiler', String(post.is_content_spoiler));

  return {
    title: post.title,
    // 2. 결정된 설명을 모든 description 필드에 적용합니다.
    description: displayDescription,
    openGraph: {
      title: post.title,
      description: displayDescription,
      images: [ogImageUrl.toString()],
      type: 'article',
    },
    twitter: {
      card: 'summary_large_image',
      title: post.title,
      description: displayDescription,
      images: [ogImageUrl.toString()],
    },
  };
}

export default async function ViewPage({ params }: { params: { id: string } }) {
  // ... (이 컴포넌트는 변경 없음)
  const post = await getPostData(params.id);
  if (!post) notFound();
  return (
    <main className="flex min-h-screen justify-center bg-gray-100 py-8 px-4">
      <article className="prose lg:prose-xl w-full max-w-4xl bg-white p-8 sm:p-12 rounded-lg shadow-lg">
        <h1>{post.title}</h1>
        <ReactMarkdown remarkPlugins={[remarkGfm]} components={{ 'img': ({ node, ...props }) => ( <img {...props} style={{ maxWidth: '100%', height: 'auto', borderRadius: '8px' }} alt="" /> ) }}>
          {post.content}
        </ReactMarkdown>
      </article>
    </main>
  );
}