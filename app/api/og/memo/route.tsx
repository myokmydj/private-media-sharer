// app/api/og/memo/route.tsx (ìµœì¢… ìˆ˜ì •ë³¸)

import { ImageResponse } from 'next/og';
import { NextRequest } from 'next/server';

export const runtime = 'edge';

function parseContent(content: string, spoilerIcon: string) {
  const trimmedContent = content.length > 200 ? content.substring(0, 200) + '...' : content;
  const parts = trimmedContent.split(/(\|\|.*?\|\|)/g).filter(Boolean);
  
  return parts.map(part => {
    if (part.startsWith('||') && part.endsWith('||')) {
      return { isSpoiler: true, text: spoilerIcon };
    }
    return { isSpoiler: false, text: part };
  });
}

async function getImageBuffer(url: string | null, defaultImagePath: string, baseUrl: string): Promise<ArrayBuffer> {
    let imageUrl = url;
    if (url && url.startsWith('/')) {
        imageUrl = new URL(url, baseUrl).toString();
    }
    try {
        if (!imageUrl || !imageUrl.startsWith('http')) throw new Error("Invalid URL");
        const response = await fetch(imageUrl);
        if (!response.ok) throw new Error(`Failed to fetch image`);
        return await response.arrayBuffer();
    } catch (e) {
        const defaultUrl = new URL(defaultImagePath, baseUrl).toString();
        const response = await fetch(defaultUrl);
        return await response.arrayBuffer();
    }
}

export async function GET(req: NextRequest) {
  try {
    const { nextUrl } = req;
    const searchParams = nextUrl.searchParams;
    const baseUrl = nextUrl.origin;

    const userName = searchParams.get('userName') || 'USER';
    const userImage = searchParams.get('userImage');
    const userHeaderImage = searchParams.get('userHeaderImage');
    const content = searchParams.get('content') || 'ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤.';
    const spoilerIcon = searchParams.get('spoilerIcon') || 'ğŸ”‘';

    const processedContent = parseContent(content, spoilerIcon);

    const [regularFontData, blackFontData, monoFontData, headerImageBuffer, profileImageBuffer] = await Promise.all([
        fetch(new URL('/Freesentation-4Regular.ttf', baseUrl)).then(res => res.arrayBuffer()),
        fetch(new URL('/Freesentation-9Black.ttf', baseUrl)).then(res => res.arrayBuffer()),
        fetch(new URL('/RobotoMono-Regular.ttf', baseUrl)).then(res => res.arrayBuffer()),
        getImageBuffer(userHeaderImage, '/default-header.png', baseUrl),
        getImageBuffer(userImage, '/default-avatar.png', baseUrl)
    ]);

    const headerImageSrc = headerImageBuffer as any;
    const profileImageSrc = profileImageBuffer as any;
    const currentDate = new Date().toISOString().split('T')[0];

    return new ImageResponse(
      (
        <div tw="w-full h-full flex relative bg-neutral-100">
          <div tw="absolute inset-0 flex">
            <img 
              src={headerImageSrc} 
              tw="absolute inset-0 w-full h-full" 
              style={{ objectFit: 'cover', opacity: 0.3 }} 
            />
            <div tw="absolute inset-0 w-full h-full bg-white/20" />
          </div>

          <div tw="w-full h-full flex items-center justify-center relative">
            <div tw="w-[1000px] h-[500px] bg-white/90 border border-gray-200/50 rounded-lg shadow-2xl flex flex-col p-12"
                 style={{ backdropFilter: 'blur(10px)' }}>
              
              <div tw="flex justify-between items-center text-xs uppercase" style={{ fontFamily: 'Roboto Mono' }}>
                <span>Memo / Private Sharing</span>
                <span>Date: {currentDate}</span>
              </div>
              <div tw="w-full h-px bg-gray-300 my-4" />
              
              {/* â–¼â–¼â–¼ [í•µì‹¬ ìˆ˜ì •] ì—¬ê¸°ì— flexì™€ flex-wrapì„ ì¶”ê°€í–ˆìŠµë‹ˆë‹¤. â–¼â–¼â–¼ */}
              <div tw="flex flex-wrap flex-grow text-2xl text-neutral-800" style={{ fontFamily: 'Freesentation', lineHeight: 1.7 }}>
                {processedContent.map((part, i) => (
                  <span key={i} tw={part.isSpoiler ? 'text-4xl' : ''}>{part.text}</span>
                ))}
              </div>
              {/* â–²â–²â–² ì—¬ê¸°ê¹Œì§€ ìˆ˜ì • â–²â–²â–² */}

              <div tw="text-xs text-gray-400" style={{ fontFamily: 'Roboto Mono' }}>
                Generated by private-media-sharer.vercel.app
              </div>
            </div>

            <div 
              tw="absolute top-1/2 right-12 w-64 h-auto bg-white p-6 rounded-lg shadow-xl border border-gray-200 flex flex-col items-center"
              style={{ transform: 'translateY(-50%)' }}
            >
              <img 
                src={profileImageSrc} 
                tw="w-24 h-24 rounded-full border-4 border-white shadow-md -mt-16" 
                style={{ objectFit: 'cover' }}
              />
              <span tw="mt-4 text-2xl text-neutral-800" style={{ fontWeight: 900, fontFamily: 'Freesentation' }}>
                {userName}
              </span>
              <span tw="text-xs text-gray-400 mt-1" style={{ fontFamily: 'Roboto Mono' }}>
                MEMO BY
              </span>
            </div>
          </div>
        </div>
      ),
      {
        width: 1200,
        height: 630,
        fonts: [
          { name: 'Freesentation', data: regularFontData, weight: 400, style: 'normal' },
          { name: 'Freesentation', data: blackFontData, weight: 900, style: 'normal' },
          { name: 'Roboto Mono', data: monoFontData, weight: 400, style: 'normal' },
        ],
      }
    );
  } catch (e: any) {
    console.error(`OG Memo generation failed: ${e.message}`);
    return new Response('Failed to generate OG image', { status: 500 });
  }
}