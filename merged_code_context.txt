--- START OF PROJECT CONTEXT ---
Generated on: 10/03/2025 11:59:04



============================================================
FILE: next.config.ts
============================================================

import type { NextConfig } from 'next';

const nextConfig: NextConfig = {
  images: {
    // remotePatterns 대신 domains를 사용합니다.
    // 여기에 Step 1에서 복사한 정확한 호스트 이름을 붙여넣으세요.
    domains: ['pub-36efcebb6f624798b7169d496005c244.r2.dev'], 
  },
};

export default nextConfig;



============================================================
FILE: package.json
============================================================

{
  "name": "private-media-sharer",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build --turbopack",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@aws-sdk/client-s3": "^3.901.0",
    "@aws-sdk/s3-request-presigner": "^3.901.0",
    "@vercel/postgres": "^0.10.0",
    "bcrypt": "^6.0.0",
    "nanoid": "^5.1.6",
    "next": "15.5.4",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-markdown": "^10.1.0",
    "rehype-raw": "^7.0.0",
    "remark-breaks": "^4.0.0",
    "remark-gfm": "^4.0.1",
    "satori": "^0.18.3",
    "sharp": "^0.34.4"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4.1.14",
    "@tailwindcss/typography": "^0.5.19",
    "@types/bcrypt": "^6.0.0",
    "@types/node": "^20.19.19",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "autoprefixer": "^10.4.21",
    "dotenv": "^17.2.3",
    "eslint": "^9",
    "eslint-config-next": "15.5.4",
    "postcss": "^8.5.6",
    "tailwindcss": "^3.3.0",
    "typescript": "^5"
  }
}



============================================================
FILE: tailwind.config.ts
============================================================

// tailwind.config.ts

import type { Config } from 'tailwindcss';

const config: Config = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      // ▼▼▼ 여기에 폰트 패밀리 추가 ▼▼▼
      fontFamily: {
        pretendard: ['Pretendard', 'sans-serif'],
        bookkmyungjo: ['BookkMyungjo', 'serif'],
        freesentation: ['Freesentation', 'sans-serif'],
      },
      // ▲▲▲ 여기까지 추가 ▲▲▲
    },
  },
  plugins: [
    require('@tailwindcss/typography'),
  ],
};
export default config;


============================================================
FILE: app/globals.css
============================================================

/* app/globals.css */

@font-face {
    font-family: 'Pretendard';
    src: url('https://cdn.jsdelivr.net/gh/Project-Noonnu/noonfonts_2107@1.1/Pretendard-Thin.woff') format('woff');
    font-weight: 100;
    font-display: swap;
}

@font-face {
    font-family: 'Pretendard';
    src: url('https://cdn.jsdelivr.net/gh/Project-Noonnu/noonfonts_2107@1.1/Pretendard-ExtraLight.woff') format('woff');
    font-weight: 200;
    font-display: swap;
}

@font-face {
    font-family: 'Pretendard';
    src: url('https://cdn.jsdelivr.net/gh/Project-Noonnu/noonfonts_2107@1.1/Pretendard-Light.woff') format('woff');
    font-weight: 300;
    font-display: swap;
}

@font-face {
    font-family: 'Pretendard';
    src: url('https://cdn.jsdelivr.net/gh/Project-Noonnu/noonfonts_2107@1.1/Pretendard-Regular.woff') format('woff');
    font-weight: 400;
    font-display: swap;
}

@font-face {
    font-family: 'Pretendard';
    src: url('https://cdn.jsdelivr.net/gh/Project-Noonnu/noonfonts_2107@1.1/Pretendard-Medium.woff') format('woff');
    font-weight: 500;
    font-display: swap;
}

@font-face {
    font-family: 'Pretendard';
    src: url('https://cdn.jsdelivr.net/gh/Project-Noonnu/noonfonts_2107@1.1/Pretendard-SemiBold.woff') format('woff');
    font-weight: 600;
    font-display: swap;
}

@font-face {
    font-family: 'Pretendard';
    src: url('https://cdn.jsdelivr.net/gh/Project-Noonnu/noonfonts_2107@1.1/Pretendard-Bold.woff') format('woff');
    font-weight: 700;
    font-display: swap;
}

@font-face {
    font-family: 'Pretendard';
    src: url('https://cdn.jsdelivr.net/gh/Project-Noonnu/noonfonts_2107@1.1/Pretendard-ExtraBold.woff') format('woff');
    font-weight: 800;
    font-display: swap;
}

@font-face {
    font-family: 'Pretendard';
    src: url('https://cdn.jsdelivr.net/gh/Project-Noonnu/noonfonts_2107@1.1/Pretendard-Black.woff') format('woff');
    font-weight: 900;
    font-display: swap;
}

@font-face {
    font-family: 'BookkMyungjo';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2302@1.0/BookkMyungjo-Lt.woff2') format('woff2');
    font-weight: 400;
    font-display: swap;
}

@font-face {
    font-family: 'BookkMyungjo';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_2302@1.0/BookkMyungjo-Bd.woff2') format('woff2');
    font-weight: 700;
    font-display: swap;
}

@font-face {
    font-family: 'Presentation';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2404@1.0/Freesentation-1Thin.woff2') format('woff2');
    font-weight: 100;
    font-display: swap;
}

@font-face {
    font-family: 'Presentation';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2404@1.0/Freesentation-2ExtraLight.woff2') format('woff2');
    font-weight: 200;
    font-display: swap;
}

@font-face {
    font-family: 'Presentation';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2404@1.0/Freesentation-3Light.woff2') format('woff2');
    font-weight: 300;
    font-display: swap;
}

@font-face {
    font-family: 'Presentation';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2404@1.0/Freesentation-4Regular.woff2') format('woff2');
    font-weight: 400;
    font-display: swap;
}

@font-face {
    font-family: 'Presentation';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2404@1.0/Freesentation-5Medium.woff2') format('woff2');
    font-weight: 500;
    font-display: swap;
}

@font-face {
    font-family: 'Presentation';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2404@1.0/Freesentation-6SemiBold.woff2') format('woff2');
    font-weight: 600;
    font-display: swap;
}

@font-face {
    font-family: 'Presentation';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2404@1.0/Freesentation-7Bold.woff2') format('woff2');
    font-weight: 700;
    font-display: swap;
}

@font-face {
    font-family: 'Presentation';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2404@1.0/Freesentation-8ExtraBold.woff2') format('woff2');
    font-weight: 800;
    font-display: swap;
}

@font-face {
    font-family: 'Presentation';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2404@1.0/Freesentation-9Black.woff2') format('woff2');
    font-weight: 900;
    font-display: swap;
}

@tailwind base;
@tailwind components;
@tailwind utilities;


/* ▼▼▼ 스포일러 스타일을 아래 코드로 교체 ▼▼▼ */
.spoiler {
  color: #6d6d6d; /* 텍스트를 투명하게 만듭니다 */
  filter: blur(5px); /* 블러 효과를 적용합니다 (수치는 조절 가능) */
  cursor: pointer;
  transition: all 0.3s ease-in-out;
  /* 선택 방지를 위해 user-select를 추가할 수 있습니다 (선택 사항) */
  user-select: none; 
}

.spoiler-revealed {
  color: inherit; /* 원래 텍스트 색상으로 복원합니다 */
  filter: blur(0); /* 블러 효과를 제거합니다 */
  cursor: default;
  user-select: auto;
}
/* ▲▲▲ 여기까지 교체 ▲▲▲ */


============================================================
FILE: app/layout.tsx
============================================================

import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}



============================================================
FILE: app/upload/page.tsx
============================================================

'use client';

import { useState, ChangeEvent, FormEvent, useRef } from 'react'; // 👈 useRef import
import Image from 'next/image';

export default function UploadPage() {
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  const [thumbnailUrl, setThumbnailUrl] = useState<string>('');
  const [isThumbnailUploading, setIsThumbnailUploading] = useState(false);
  const [isBlurred, setIsBlurred] = useState(false);
  const [isSpoiler, setIsSpoiler] = useState(false);
  const [isUploading, setIsUploading] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [generatedLink, setGeneratedLink] = useState('');
  const [error, setError] = useState('');
  const [selectedFont, setSelectedFont] = useState('font-pretendard');
  const [password, setPassword] = useState('');

  const contentRef = useRef<HTMLTextAreaElement>(null); // 👈 textarea를 위한 ref 생성

  const fontClasses: { [key: string]: string } = {
    'font-pretendard': '프리텐다드 (고딕)',
    'font-bookkmyungjo': '북크 명조',
    'font-freesentation': '프리젠테이션 (고딕)',
  };

  // ... (handleThumbnailUpload, handleFileChange 함수는 변경 없음) ...
  const handleThumbnailUpload = async (event: ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;
    setIsThumbnailUploading(true);
    setError('');
    const formData = new FormData();
    formData.append('file', file);
    try {
      const response = await fetch('/api/upload', { method: 'POST', body: formData });
      const data = await response.json();
      if (!response.ok) throw new Error(data.error);
      setThumbnailUrl(data.url);
    } catch (err) {
      setError(err instanceof Error ? err.message : '대표 이미지 업로드 실패');
    } finally {
      setIsThumbnailUploading(false);
    }
  };

  const handleFileChange = async (event: ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files;
    if (!files || files.length === 0) return;
    setIsUploading(true);
    setError('');
    for (const file of Array.from(files)) {
      const formData = new FormData();
      formData.append('file', file);
      try {
        const response = await fetch('/api/upload', { method: 'POST', body: formData });
        const data = await response.json();
        if (!response.ok) throw new Error(data.error);
        setContent(prev => `${prev}\n\n![${data.filename}](${data.url})`);
      } catch (err) {
        setError(err instanceof Error ? err.message : '파일 업로드 실패');
      }
    }
    setIsUploading(false);
  };

  const handleSubmit = async (event: FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    if (!title || !content || !thumbnailUrl) {
      setError('제목, 내용, 대표 이미지를 모두 설정해주세요.');
      return;
    }
    setIsSubmitting(true);
    setError('');
    setGeneratedLink('');

    try {
      const response = await fetch('/api/posts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          title, 
          content, 
          thumbnailUrl,
          isThumbnailBlurred: isBlurred,
          isContentSpoiler: isSpoiler,
          selectedFont,
          password,
        }),
      });

      const data = await response.json();
      if (!response.ok) throw new Error(data.error);

      setGeneratedLink(data.url);
      setTitle('');
      setContent('');
      setThumbnailUrl('');
      setIsBlurred(false);
      setIsSpoiler(false);
      setPassword('');

    } catch (err) {
      setError(err instanceof Error ? err.message : '게시물 생성 실패');
    } finally {
      setIsSubmitting(false);
    }
  };

  // ▼▼▼ 스포일러 텍스트 자동 삽입 함수 ▼▼▼
  const insertSpoilerText = () => {
    const textarea = contentRef.current;
    if (!textarea) return;

    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const selectedText = content.substring(start, end);
    const spoilerText = `블러[${selectedText || '가릴 내용'}]`;

    const newContent = content.substring(0, start) + spoilerText + content.substring(end);
    setContent(newContent);

    // 삽입 후 textarea에 포커스를 주고 커서 위치를 조정합니다.
    textarea.focus();
    setTimeout(() => {
      const newCursorPosition = start + spoilerText.length - (selectedText ? 1 : 6);
      textarea.setSelectionRange(newCursorPosition, newCursorPosition);
    }, 0);
  };

  return (
    <main className={`flex min-h-screen flex-col items-center justify-center p-4 sm:p-8 bg-gray-50 ${selectedFont}`}>
      <div className="w-full max-w-3xl p-8 space-y-6 bg-white rounded-lg shadow-md">
        <h1 className="text-3xl font-bold text-center text-gray-800">새 게시물 작성</h1>
        
        <div>
          <label htmlFor="font-select" className="block text-sm font-medium text-gray-700">폰트 선택</label>
          <select id="font-select" value={selectedFont} onChange={(e) => setSelectedFont(e.target.value)} className="mt-1 block w-full px-3 py-2 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
            {Object.entries(fontClasses).map(([className, name]) => ( <option key={className} value={className}>{name}</option>))}
          </select>
        </div>

        <form onSubmit={handleSubmit} className="space-y-6">
          <div><label htmlFor="title" className="block text-sm font-medium text-gray-700">제목</label><input id="title" type="text" value={title} onChange={(e) => setTitle(e.target.value)} className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" required /></div>
          
          <div>
            <label htmlFor="thumbnail-upload" className="block text-sm font-medium text-gray-700">대표 이미지 (SNS 미리보기에 사용)</label>
            <input id="thumbnail-upload" type="file" accept="image/*" onChange={handleThumbnailUpload} disabled={isThumbnailUploading} className="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-violet-50 file:text-violet-700 hover:file:bg-violet-100" />
            {isThumbnailUploading && <p className="text-sm text-gray-500 mt-2">대표 이미지 업로드 중...</p>}
            {thumbnailUrl && (
              <div className="mt-4 relative w-full aspect-video rounded-lg overflow-hidden border">
                <Image src={thumbnailUrl} alt="대표 이미지 미리보기" fill className="object-cover" />
              </div>
            )}
          </div>
          
          <div><label htmlFor="file" className="block text-sm font-medium text-gray-700">본문 이미지 (여러 개 선택 가능)</label><input id="file" type="file" multiple onChange={handleFileChange} disabled={isUploading} className="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-violet-50 file:text-violet-700 hover:file:bg-violet-100" />{isUploading && <p className="text-sm text-gray-500 mt-2">업로드 중...</p>}</div>
          
          <div>
            <div className="flex justify-between items-center">
              <label htmlFor="content" className="block text-sm font-medium text-gray-700">본문 (Markdown 지원)</label>
              {/* ▼▼▼ 스포일러 추가 버튼 ▼▼▼ */}
              <button type="button" onClick={insertSpoilerText} className="px-2 py-1 text-xs font-semibold text-white bg-gray-600 rounded-md hover:bg-gray-700">
                스포일러 추가
              </button>
            </div>
            <textarea 
              ref={contentRef} // 👈 ref 연결
              id="content" 
              rows={10} 
              value={content} 
              onChange={(e) => setContent(e.target.value)} 
              className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" 
              required 
            />
          </div>
          
          <div className="space-y-4 rounded-md border border-gray-200 p-4">
            <h3 className="text-sm font-medium text-gray-900">옵션</h3>
            <div className="relative flex items-start">
              <div className="flex h-6 items-center"><input id="blur-toggle" type="checkbox" checked={isBlurred} onChange={(e) => setIsBlurred(e.target.checked)} className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-600" /></div>
              <div className="ml-3 text-sm leading-6"><label htmlFor="blur-toggle" className="font-medium text-gray-700">대표 이미지 흐리게 처리</label><p className="text-gray-500">SNS 공유 시 썸네일을 블러 처리하여 가립니다.</p></div>
            </div>
            <div className="relative flex items-start">
              <div className="flex h-6 items-center"><input id="spoiler-toggle" type="checkbox" checked={isSpoiler} onChange={(e) => setIsSpoiler(e.target.checked)} className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-600" /></div>
              <div className="ml-3 text-sm leading-6"><label htmlFor="spoiler-toggle" className="font-medium text-gray-700">본문 내용 스포일러 처리</label><p className="text-gray-500">SNS 공유 시 본문 내용을 가립니다.</p></div>
            </div>
             <div>
              <label htmlFor="password" className="block text-sm font-medium text-gray-700">비밀번호 설정 (선택 사항)</label>
              <input id="password" type="password" value={password} onChange={(e) => setPassword(e.target.value)} className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="비밀번호를 입력하면 게시물이 보호됩니다."/>
            </div>
          </div>

          <button type="submit" disabled={isSubmitting || isUploading || isThumbnailUploading} className="w-full px-4 py-2 text-lg font-medium text-white bg-indigo-600 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:bg-gray-400">
            {isSubmitting ? '생성 중...' : '공유 링크 생성'}
          </button>
        </form>

        {error && <p className="mt-4 text-sm text-center text-red-600">{error}</p>}
        {generatedLink && (
          <div className="mt-6 p-4 bg-green-50 border border-green-200 rounded-md">
            <p className="text-sm font-medium text-green-800">✅ 성공! 생성된 링크:</p>
            <a href={generatedLink} target="_blank" rel="noopener noreferrer" className="block mt-1 text-sm text-blue-600 break-all hover:underline">{generatedLink}</a>
          </div>
        )}
      </div>
    </main>
  );
}


============================================================
FILE: app/view/[id]/page.tsx
============================================================

import { notFound } from 'next/navigation';
import { db } from '@vercel/postgres';
import type { Metadata } from 'next';
import { unstable_noStore as noStore } from 'next/cache';
import PostContent from './PostContent';
import PasswordProtect from './PasswordProtect';

interface Post {
  id: string;
  title: string;
  content: string;
  thumbnail_url: string;
  is_thumbnail_blurred: boolean;
  is_content_spoiler: boolean;
  font_family: string | null; // DB에 값이 없을 수 있으므로 nullable
  password: string | null; // DB에 값이 없을 수 있으므로 nullable
  created_at: string;
}

async function getPostData(id: string): Promise<Post | null> {
  noStore();
  try {
    const { rows } = await db.sql`SELECT * FROM posts WHERE id = ${id} LIMIT 1;`;
    if (rows.length === 0) return null;
    return rows[0] as Post;
  } catch (error) {
    console.error("Database query failed:", error);
    return null;
  }
}

export async function generateMetadata({ params }: { params: { id:string } }): Promise<Metadata> {
  const post = await getPostData(params.id);

  if (!post) {
    return { title: '게시물을 찾을 수 없습니다' };
  }

  const originalDescription = post.content ? post.content.replace(/\n/g, ' ').substring(0, 50) + (post.content.length > 50 ? '...' : '') : '';
  const displayDescription = post.is_content_spoiler 
    ? '내용이 가려졌습니다. 링크를 클릭해 확인하세요.' 
    : originalDescription || '친구로부터 공유된 게시물을 확인하세요.';

  const ogImageUrl = new URL(`${process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : 'http://localhost:3000'}/api/og`);
  ogImageUrl.searchParams.set('title', post.title);
  if (originalDescription) ogImageUrl.searchParams.set('artist', originalDescription);
  ogImageUrl.searchParams.set('imageUrl', post.thumbnail_url);
  ogImageUrl.searchParams.set('isBlurred', String(post.is_thumbnail_blurred));
  ogImageUrl.searchParams.set('isSpoiler', String(post.is_content_spoiler));

  return {
    title: post.title,
    description: displayDescription,
    openGraph: {
      title: post.title,
      description: displayDescription,
      images: [ogImageUrl.toString()],
      type: 'article',
    },
    twitter: {
      card: 'summary_large_image',
      title: post.title,
      description: displayDescription,
      images: [ogImageUrl.toString()],
    },
  };
}

export default async function ViewPage({ params }: { params: { id: string } }) {
  const post = await getPostData(params.id);
  if (!post) notFound();
  
  return (
    <main className={`flex min-h-screen items-center justify-center bg-gray-100 py-8 px-4 ${post.font_family || 'font-pretendard'}`}>
      {post.password ? (
        <PasswordProtect post={post} />
      ) : (
        <PostContent post={post} />
      )}
    </main>
  );
}


============================================================
FILE: app/view/[id]/PostContent.tsx
============================================================

'use client';

import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import remarkBreaks from 'remark-breaks';
import rehypeRaw from 'rehype-raw';
import type { Pluggable } from 'unified';
import { MouseEvent } from 'react';

interface Post {
  id: string;
  title: string;
  content: string;
  thumbnail_url: string;
  is_thumbnail_blurred: boolean;
  is_content_spoiler: boolean;
  font_family: string | null;
  password: string | null;
  created_at: string;
}

export default function PostContent({ post }: { post: Post }) {
  
  const handleSpoilerClick = (e: MouseEvent<HTMLElement>) => {
    const target = e.target as HTMLElement;
    if (target.classList.contains('spoiler')) {
      target.classList.remove('spoiler');
      target.classList.add('spoiler-revealed');
    }
  };

  // ▼▼▼ '블러[...]' 치환자를 HTML 태그로 변환하는 로직 ▼▼▼
  const processContentForSpoilers = (text: string) => {
    // /블러\[(.*?)\]/g 정규식:
    // '블러[' 로 시작하고 ']' 로 끝나는 모든 문자열을 찾습니다.
    // (.*?) 는 괄호 안의 내용을 캡처합니다. '?'는 탐욕적이지 않은(non-greedy) 매칭을 의미합니다.
    // g 플래그는 문자열 전체에서 모든 일치 항목을 찾도록 합니다.
    return text.replace(/블러\[(.*?)\]/g, '<span class="spoiler">$1</span>');
  };

  const processedContent = processContentForSpoilers(post.content);

  return (
    <article 
      className="prose lg:prose-lg w-full max-w-3xl bg-white p-6 sm:p-10 rounded-lg shadow-lg"
      onClick={handleSpoilerClick}
    >
      <h1>{post.title}</h1>
      <ReactMarkdown 
        remarkPlugins={[remarkGfm, remarkBreaks] as Pluggable[]}
        rehypePlugins={[rehypeRaw]}
        components={{ 
          'img': ({ node, ...props }) => ( 
            <img {...props} style={{ maxWidth: '100%', height: 'auto', borderRadius: '8px' }} alt="" /> 
          ) 
        }}
      >
        {processedContent}
      </ReactMarkdown>
    </article>
  );
}


============================================================
FILE: app/view/[id]/PasswordProtect.tsx
============================================================

'use client';

import { useState, FormEvent } from 'react';
import PostContent from './PostContent';

// Post 타입을 page.tsx와 동일하게 정의
interface Post {
  id: string;
  title: string;
  content: string;
  thumbnail_url: string;
  is_thumbnail_blurred: boolean;
  is_content_spoiler: boolean;
  font_family: string | null;
  password: string | null;
  created_at: string;
}

export default function PasswordProtect({ post }: { post: Post }) {
  const [isVerified, setIsVerified] = useState(false);
  const [passwordInput, setPasswordInput] = useState('');
  const [error, setError] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsLoading(true);
    setError('');

    try {
      const response = await fetch('/api/verify-password', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id: post.id, password: passwordInput }),
      });

      const data = await response.json();

      if (response.ok && data.success) {
        setIsVerified(true);
      } else {
        setError(data.error || '인증에 실패했습니다.');
      }
    } catch (err) {
      setError('네트워크 오류가 발생했습니다.');
    } finally {
      setIsLoading(false);
    }
  };

  if (isVerified) {
    return <PostContent post={post} />;
  }

  return (
    <div className="w-full max-w-md p-8 space-y-6 bg-white rounded-lg shadow-md">
      <h2 className="text-2xl font-bold text-center text-gray-800">비밀번호 필요</h2>
      <p className="text-center text-sm text-gray-600">이 콘텐츠를 보려면 비밀번호를 입력하세요.</p>
      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <label htmlFor="password-input" className="sr-only">비밀번호</label>
          <input
            id="password-input"
            type="password"
            value={passwordInput}
            onChange={(e) => setPasswordInput(e.target.value)}
            className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500"
            placeholder="비밀번호"
            required
          />
        </div>
        {error && <p className="text-sm text-red-600">{error}</p>}
        <button
          type="submit"
          disabled={isLoading}
          className="w-full px-4 py-2 font-medium text-white bg-indigo-600 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:bg-gray-400"
        >
          {isLoading ? '확인 중...' : '확인'}
        </button>
      </form>
    </div>
  );
}


============================================================
FILE: app/api/posts/route.ts
============================================================

import { NextResponse } from 'next/server';
import { db } from '@vercel/postgres';
import { nanoid } from 'nanoid';
import bcrypt from 'bcrypt';

export async function POST(request: Request) {
  try {
    const { 
      title, 
      content, 
      thumbnailUrl, 
      isThumbnailBlurred, 
      isContentSpoiler, 
      selectedFont,
      password // 👈 비밀번호 추가
    } = await request.json();

    if (!title || !content || !thumbnailUrl) {
      return NextResponse.json({ error: '제목, 내용, 대표 이미지는 필수입니다.' }, { status: 400 });
    }

    let hashedPassword = null;
    if (password && password.length > 0) {
      // 비밀번호가 있을 경우에만 해싱
      const saltRounds = 10;
      hashedPassword = await bcrypt.hash(password, saltRounds);
    }

    const id = nanoid();

    await db.sql`
      INSERT INTO posts (id, title, content, thumbnail_url, is_thumbnail_blurred, is_content_spoiler, font_family, password)
      VALUES (${id}, ${title}, ${content}, ${thumbnailUrl}, ${isThumbnailBlurred}, ${isContentSpoiler}, ${selectedFont}, ${hashedPassword});
    `;

    const baseUrl = process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : 'http://localhost:3000';
    const generatedUrl = `${baseUrl}/view/${id}`;

    return NextResponse.json({ success: true, url: generatedUrl });

  } catch (error) {
    console.error('Create Post API Error:', error);
    return NextResponse.json({ error: '게시물 생성 중 서버에서 에러가 발생했습니다.' }, { status: 500 });
  }
}


============================================================
FILE: app/api/upload/route.ts
============================================================

import { NextResponse } from 'next/server';
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
import { nanoid } from 'nanoid';

const s3Client = new S3Client({
  region: 'auto',
  endpoint: process.env.R2_ENDPOINT!,
  credentials: {
    accessKeyId: process.env.R2_ACCESS_KEY_ID!,
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY!,
  },
});

function getPublicUrl(filename: string): string {
  const publicUrlBase = process.env.NEXT_PUBLIC_R2_PUBLIC_URL!;
  return `${publicUrlBase.replace(/\/$/, '')}/${filename}`;
}

export async function POST(request: Request) {
  try {
    const formData = await request.formData();
    const file = formData.get('file') as File | null;

    if (!file) {
      return NextResponse.json({ error: '파일이 없습니다.' }, { status: 400 });
    }

    const buffer = Buffer.from(await file.arrayBuffer());
    const uniqueId = nanoid(10); // 짧은 고유 ID
    const key = `${uniqueId}-${file.name}`;

    const command = new PutObjectCommand({
      Bucket: process.env.R2_BUCKET_NAME!,
      Key: key,
      Body: buffer,
      ContentType: file.type,
    });
    
    await s3Client.send(command);

    const publicUrl = getPublicUrl(key);

    // 이제 DB에 저장하지 않고, 업로드된 파일의 URL과 파일명만 반환합니다.
    return NextResponse.json({ success: true, url: publicUrl, filename: file.name });

  } catch (error) {
    console.error('Upload API Error:', error);
    return NextResponse.json({ error: '파일 업로드 중 서버에서 에러가 발생했습니다.' }, { status: 500 });
  }
}


============================================================
FILE: app/api/og/route.tsx
============================================================

import { ImageResponse } from 'next/og';
import { NextRequest } from 'next/server';
import { join } from 'path';
import * as fs from 'fs';

export const runtime = 'nodejs';

// 👇 두 개의 폰트 파일을 불러옵니다.
const fontBoldPath = join(process.cwd(), 'public', 'fonts', 'PretendardJP-Black.otf'); // 사용자님의 파일 이름으로
const fontRegularPath = join(process.cwd(), 'public', 'fonts', 'PretendardJP-Medium.otf'); // 사용자님의 파일 이름으로
const pretendardBold = fs.readFileSync(fontBoldPath);
const pretendardRegular = fs.readFileSync(fontRegularPath);

export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);

    const title = searchParams.get('title') || '제목 없음';
    const artist = searchParams.get('artist');
    const imageUrl = searchParams.get('imageUrl');
    // 👇 새로운 파라미터 수신
    const isBlurred = searchParams.get('isBlurred') === 'true';
    const isSpoiler = searchParams.get('isSpoiler') === 'true';

    return new ImageResponse(
      (
        <div style={{ height: '100%', width: '100%', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', backgroundColor: '#28234D', color: 'white', padding: '40px' }}>
          <div style={{ display: 'flex', width: '100%', height: '100%' }}>
            {imageUrl && (
              // eslint-disable-next-line @next/next/no-img-element
              <img
                src={imageUrl}
                alt=""
                width={550}
                height={550}
                style={{
                  borderRadius: '20px',
                  objectFit: 'cover',
                  // 👇 isBlurred 값에 따라 블러 효과 적용
                  filter: isBlurred ? 'blur(20px)' : 'none',
                }}
              />
            )}
            <div style={{ display: 'flex', flexDirection: 'column', marginLeft: '40px', flex: 1, justifyContent: 'space-between' }}>
              {/* 👇 상단 로고를 Font Awesome 음악 아이콘으로 교체 */}
              <div style={{ display: 'flex', justifyContent: 'flex-end', opacity: 0.8 }}>
              <svg xmlns="http://www.w3.org/2000/svg" height="80" width="80" viewBox="0 0 512 512" fill="white">
                <path d="M499.1 6.3c-13.1-8.1-28.3-6.3-39.2 4.4L393.5 64H320c-17.7 0-32 14.3-32 32s14.3 32 32 32h64v64c0 17.7 14.3 32 32 32s32-14.3 32-32V128h6.5c13.8 0 26.1-8.1 31-20.5s.7-26.6-8.4-35.2L499.1 6.3z" />
                <path d="M23.1 406.3c-13.1-8.1-28.3-6.3-39.2 4.4L-82.5 464H-156c-17.7 0-32 14.3-32 32s14.3 32 32 32h64v64c0 17.7 14.3 32 32 32s32-14.3 32-32V528h6.5c13.8 0 26.1-8.1 31-20.5s.7-26.6-8.4-35.2L23.1 406.3z" />
                <path d="M256 0c-17.7 0-32 14.3-32 32V480c0 17.7 14.3 32 32 32s32-14.3 32-32V32c0-17.7-14.3-32-32-32z" />
              </svg>
            </div>
              <div style={{ display: 'flex', flexDirection: 'column', fontFamily: '"PretendardJP-Black"' }}>
                <div style={{ fontSize: '60px', fontWeight: 'bold', letterSpacing: '-0.02em' }}>
                  {title}
                </div>
                {/* 👇 isSpoiler 값에 따라 본문 또는 스포일러 문구 표시 */}
                {artist && (
                  <div style={{
                    fontSize: '40px',
                    marginTop: '10px',
                    opacity: 0.7,
                    wordBreak: 'break-all',
                    lineHeight: 1.3,
                    // 👇 얇은 폰트 적용
                    fontFamily: '"PretendardJP-Medium"',
                    fontWeight: 400,
                  }}>
                    {isSpoiler ? '내용이 가려졌습니다.' : artist}
                  </div>
                )}
              </div>
              <div style={{ display: 'flex', justifyContent: 'flex-end' }}>
                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', width: '100px', height: '100px', backgroundColor: 'white', borderRadius: '50%' }}>
                  <svg width="50" height="50" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M8 5.13965V18.8604C8 19.56 8.66274 20.0168 9.30852 19.642L20.6915 12.7816C21.3373 12.4078 21.3373 11.5922 20.6915 11.2184L9.30852 4.35795C8.66274 3.98317 8 4.44004 8 5.13965Z" fill="#28234D"/>
                  </svg>
                </div>
              </div>
            </div>
          </div>
        </div>
      ),
      { width: 1200, height: 630, fonts: [{ name: 'PretendardJP-Black', data: pretendardBold, style: 'normal', weight: 800 }, { name: 'PretendardJP-Medium', data: pretendardRegular, style: 'normal', weight: 400 }] },
    );
  } catch (e: unknown) {
    if (e instanceof Error) console.error(`OG Image generation failed: ${e.message}`);
    else console.error('An unknown error occurred during OG Image generation');
    return new Response(`Failed to generate the image`, { status: 500 });
  }
}


============================================================
FILE: app/api/verify-password/route.ts
============================================================

import { NextResponse } from 'next/server';
import { db } from '@vercel/postgres';
import bcrypt from 'bcrypt';

export async function POST(request: Request) {
  try {
    const { id, password } = await request.json();

    if (!id || !password) {
      return NextResponse.json({ error: 'ID와 비밀번호를 모두 입력해야 합니다.' }, { status: 400 });
    }

    const { rows } = await db.sql`SELECT password FROM posts WHERE id = ${id} LIMIT 1;`;

    if (rows.length === 0) {
      return NextResponse.json({ error: '게시물을 찾을 수 없습니다.' }, { status: 404 });
    }

    const hashedPassword = rows[0].password;
    if (!hashedPassword) {
        // DB에 비밀번호가 없는 경우 (오류 상황)
        return NextResponse.json({ error: '이 게시물에는 비밀번호가 설정되어 있지 않습니다.' }, { status: 400 });
    }

    const isMatch = await bcrypt.compare(password, hashedPassword);

    if (isMatch) {
      return NextResponse.json({ success: true });
    } else {
      return NextResponse.json({ success: false, error: '비밀번호가 일치하지 않습니다.' }, { status: 401 });
    }

  } catch (error) {
    console.error('Verify Password API Error:', error);
    return NextResponse.json({ error: '비밀번호 확인 중 서버 에러가 발생했습니다.' }, { status: 500 });
  }
}
